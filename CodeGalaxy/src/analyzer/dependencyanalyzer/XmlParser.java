package analyzer.dependencyanalyzer;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Vector;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.XMLReaderFactory;

/**
 * Created on November 4, 2014 by Ellina.
 * Parses an XML report generated by Classycle.
 * Retrieves the information from the report into objects.
 * Reference for SAX API: http://sax.sourceforge.net/quickstart.html
 */

public class XmlParser extends DefaultHandler {

	private Vector<ClassDependencyInfo> classVector = new Vector<ClassDependencyInfo>();	// vector of Class Dependency objects
	private Vector<PackageDependencyInfo> packageVector = new Vector<PackageDependencyInfo>(); // vector of Package Dependency objects

	private Vector<String> tempAfferentClassVector; // temporarily contains names of afferent classes
	private Vector<String> tempEfferentClassVector; // temporarily contains names of efferent classes
	ClassDependencyInfo classInfo = null;

	/**
	 * Default constructor.
	 */
	public XmlParser() {
		super();
	}

	/**
	 * Entry point of the XML Parser.
	 * Sets up and runs the parser given the XML file name.
	 */
	public void startXmlParser(){

		XMLReader xr;
		try {
			xr = XMLReaderFactory.createXMLReader();
			XmlParser handler = new XmlParser();
			xr.setContentHandler(handler);
			xr.setErrorHandler(handler);

			// Parse the given XML file.
			FileReader r;
			try {
				r = new FileReader("test_resources/sample.xml");
				xr.parse(new InputSource(r));

			} catch (FileNotFoundException e) {
				System.out.println("File not found. Please, indicate a valid file name.");
				System.err.println(e);
			}
			catch (IOException e) {
				System.err.println(e);
			}
		} catch (SAXException e) {
			System.err.println(e);
		}

	}


	/**
	 * Status: in progress.
	 * Analyzes the xml file to gather info on class dependencies.
	 * Adds info on each class to the classVector.
	 */
	public void analyzeXmlClassInfo(){

	}

	/**
	 * Status: in progress.
	 * Analyzes the xml file to gather info on package dependencies.
	 * Adds info on each package to the packageVector.
	 */
	public void analyzeXmlPackageInfo(){

	}

	// --------------- Event handlers --------------------------------//

	/**
	 * Handles the beginning of a document.
	 * @see org.xml.sax.helpers.DefaultHandler#startDocument()
	 */
	public void startDocument(){
		System.out.println("Start document");
	}


	/**
	 * Handles the end of a document.
	 * @see org.xml.sax.helpers.DefaultHandler#endDocument()
	 */
	public void endDocument(){
		System.out.println("End document");
	}

	/**
	 * Event handler for when the start of an element is encountered.
	 * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)
	 */
	public void startElement (String uri, String name, String qName, Attributes attributes){
		if ("".equals (uri))
			System.out.println("Start element: " + qName);
		else
			System.out.println("Start element: {" + uri + "}" + name);

		switch(qName){
		case "class":
			System.out.println(" *** Encountered a class with name: " + attributes.getValue("name"));
			System.out.println("     usedby: " + attributes.getValue("usedBy") + " uses: " + attributes.getValue("usesInternal"));

			// Create a new object
			int usedBy = Integer.parseInt(attributes.getValue("usedBy"));
			int uses = Integer.parseInt(attributes.getValue("usesInternal"));
			classInfo = new ClassDependencyInfo(usedBy, uses);
			classInfo.setClassName(attributes.getValue("name"));
			// Reset temporary vectors
			tempAfferentClassVector = new Vector<String>();
			tempEfferentClassVector = new Vector<String>();

			break;

		case "classRef":
			System.out.println(" *** Encountered a classRef with name: " + attributes.getValue("name") + " of type: " + attributes.getValue("type"));

			String refName = attributes.getValue("name");
			String refType = attributes.getValue("type");

			// If type is usedBy, then it's an Afferent class.
			int comparison = refType.compareTo("usedBy");
			if(comparison == 0) { // strings are equal
				tempAfferentClassVector.add(refName);
			}

			// If type is usesInternal, then it's an Efferent class.
			int comparisonUses = refType.compareTo("usesInternal");
			if(comparisonUses == 0) { // strings are equal
				tempEfferentClassVector.add(refName);
			}

			// If type is usesExternal, then ignore it.
			break;
		}
	}

	/**
	 * Event handler for when the end of an element is encountered.
	 * @see org.xml.sax.helpers.DefaultHandler#endElement(java.lang.String, java.lang.String, java.lang.String)
	 */
	public void endElement (String uri, String name, String qName){
		if ("".equals (uri))
			System.out.println("End element: " + qName);
		else
			System.out.println("End element:   {" + uri + "}" + name);

		switch(qName){
		case "class":
			System.out.println(" *** Encountered the end of class element.");

			// Populate an object with afferent classes
			for(int i=0; i < tempAfferentClassVector.size(); i++){
				classInfo.addAfferentClass(tempAfferentClassVector.get(i));
			}

			// Populate an object with efferent classes
			for(int i=0; i < tempEfferentClassVector.size(); i++){
				classInfo.addEfferentClass(tempEfferentClassVector.get(i));
			}

			// Save the object in a vector
			classVector.add(classInfo);

			break;
		}

	}

	/**
	 * Event handler for when the parser encounters text data.
	 * @see org.xml.sax.helpers.DefaultHandler#characters(char[], int, int)
	 */
	public void characters (char ch[], int start, int length){
	}

}
